---
title: Docker技术架构
date: 2016-03-21 12:28:18
tags: [Docker]
---

##### Docker依赖(LXC)
- `Linux Namespaces`
- `Control Groups`
- `Union File Systems`
- `Linux虚拟网络支持`

<!-- more -->

##### 基本架构
![Docker基本架构](/images/docker/dockercs.png)
- CS结构, 使用Socket和Restful API来进行通信
- 服务端
  - `Dcoker Daemon`在宿主机后台运行, 接受来自客户端的请求, 并处理这些请求(创建, 运行, 分发容器)
  - `Engine`模块来分发管理来自各个客户端的任务
  - `unix:///var/run/docker.sock`套接字 (`sudo docker -H 0.0.0.0:1234 -d &`)
- 客户端, 提供一系列命令来实现与docker daemon的交互
  - 默认向本地的`unix:///var/run/docker.sock`发送命令

##### 名称空间Namespaces
- 每个容器都有自己单独的Namespace, 运行在其中保证了就像单独运行一个操作系统一样
- 实现虚拟化, 除了要实现对内存, CPU, 网络IO, 硬盘IO, 存储空间等的限制外, 还需要实现文件系统, 网络, PID, UID, IPC的隔离, 后者的实现需要宿主机操作系统的深入支持
- Namespaces使得某些进程在运行的时候共享内核和某些运行时库, 但是彼此都是不可见的
  - 进程Namespaces
    - 同一个进程, 在不同的Namespaces下的PID是不一样的, 子名称空间对父进程的名称空间具有可见性
    - `ps -ef | grep docker`出来的Pid是容器进行的父进程号
  - 网络名称空间(进程隔离之后, 网络端口还是共享本地的网络端口)
    - ![Docker网络名称空间](/images/docker/netnamespaces.png)
    - 为进程提供了一个完全独立的网络协议栈的视图, 包括网络设备, IPV4, IPV6, 路由表, 防火墙规则, sockets等, 这样每个容器就能隔离开来
    - Docker采用虚拟网络设备(VND), 将不同名称空间的网络设备连接在一起, 默认情况下, 容器中的虚拟网卡连接到本地的主机上的docker0网桥上(一个容器虚拟网口, 连接本地网桥上的一个虚拟端口)
  - IPC Namespaces
    - 容器中的进程交互采用了Linux常见的进程间交互方法, 包括信号量, 消息队列和共享内存
    - 同一个IPC下的进程彼此可见, 允许彼此交互
  - 挂载名称空间
    - 类似chroot, 将一个进程挂载到一个特定的目录执行
    - 挂载名称空间运行不同的名称空间的进程看到的文件结构不一样, 这样每个进程中的文件目录被彼此隔离
  - UTS
    - 允许每个容器拥有独立的主机名和域名, 从而可以虚拟出一个独立的主机和网络空间环境, 就和网络上的一台主机一样
  - 用户名称空间
    - 每个容器可以有不同的用户ID和组ID, 即使用容器内的特定用户执行程序

##### 控制组
- 主要用来对共享资源进行隔离, 限制, 审计, 只有能控制分配到容器的资源, docker才能避免多个容器运行时的系统资源竞争
- 提供对容器的内存, CPU, 磁盘IO等资源的进行限制和计费管理
  - 资源限制
  - 优先级
  - 资源审计
  - 隔离
  - 控制
  - `/sys/fs/cgroup/memory/docker`可以看到docker组应用的各项限制项

##### 联合文件系统
![Docker联合文件系统](/images/docker/dockerufs.png)
- 轻量级的高性能分层文件系统, 支持将文件系统中的修改信息作为一次提交, 并层层叠加, 同时可以将不同的目录挂载到同一个虚拟文件系统下
- Docker镜像的实现基础, 镜像可以使用分层来继承
- 修改只会新增层, 分发的时候只会分发增量部分
- 每一个成员目录, 有只读, 读写, 写出的权限
- Docker启动一个容器的时候, 分配一个可读写的层给容器, 容器在这个层上建立, 并挂载到镜像层上

##### 网络实现
- 网络名称空间, 虚拟网络设备
- 网络创建过程
  ![Docker网络实现](/images/docker/dockernet.png)
  - 创建一对虚拟网络接口, 分别映射到本地主机和容器的名称空间中
  - 本地主机一端的虚拟接口映射到本地的docker0网桥或者指定网卡上
  - 容器一端的虚拟接口放到新创建的容器中, 取名为eth0, 这个接口只在容器的名称空间中使用
  - 从网桥的可用地址段中获取一个空闲地址分配给eth0, 并配置默认的
- `net=bridge`: 默认配置, 在docker网桥上为容器创建新的网络栈
- `net=host`: 告诉docker不要将容器的网络放到隔离的名称空间中, 此时容器使用的是本地主机的网络
- `net=container`: 让docker将新建立的容器放到一个已存在容器的网络协议栈中, 新容器会有自己的进程和文件系统, 但是会和已经存在的容器共享IP和端口, 两者进程可以使用localhost进行通信
- `net=none`: 让docker将新建立的容器放到隔离的网络栈中, 但是不进行网络配置, 由用户自己配置